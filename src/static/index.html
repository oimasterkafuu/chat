<!--
Chat - A simple chat application.
Copyright (C) 2024 oimaster

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>.

Contact Information:
Email: oimasterfake@icloud.com

Project URL: https://github.com/oimasterkafuu/chat
-->

<!DOCTYPE html>
<html>

<head>
    <title>简单的聊天程序</title>

    <!-- 引入 socket.io -->
    <script src="/socket.io/socket.io.js"></script>

    <!-- 引入 Dexie.js -->
    <script src="https://unpkg.com/dexie/dist/dexie.min.js"></script>
</head>

<body>
    <h1>简单的聊天程序</h1>
    <div id="messages"></div>
    <input id="number" type="number" placeholder="接收方" />
    <input id="input" type="text" placeholder="消息" />
    <input id="password" type="password" placeholder="密码" />
    <button id="send">发送</button>
    <script>
        // 初始化
        // Socket 连接
        const socket = io();
        
        // indexedDB
        const db = new Dexie('chat');
        db.version(1).stores({
            messages: '++id, text',
            number: 'numberPass'
        });

        // 查询 number 中的数据，如果没有则插入
        db.number
            .toCollection()
            .first()
            .then((number) => {
                if (!number) {
                    socket.emit('number');
                } else {
                    socket.emit('number', number.numberPass);
                }
            });

        // 绑定 DOM 元素
        const messages = document.getElementById('messages');
        const input = document.getElementById('input');
        const number = document.getElementById('number');
        const passwordInput = document.getElementById('password');
        const send = document.getElementById('send');

        // 加密标头
        const header = "OIMENC8DB3F1";

        // 收到消息
        socket.on('message', (encryptedMessage) => {
            const password = passwordInput.value;

            if (!password) {
                messages.innerHTML += `<p>请输入密码以解密消息</p>`;
                return;
            }

            const encryptedData = new Uint8Array(encryptedMessage.split('').map(char => char.charCodeAt(0)));

            decryptMessage(encryptedData, password).then((decryptedMessage) => {
                messages.innerHTML += `<p>${decryptedMessage}</p>`;
            }).catch((error) => {
                messages.innerHTML += `<p>解密失败：${error.message}</p>`;
            });
        });

        // 被赋予编号
        socket.on('number', (number) => {
            messages.innerHTML += `<p>你的数字编号是：${number}</p>`;
        });

        // 被赋予密码
        socket.on('numberpass', (numberpass) => {
            // 清空 indexedDB 中 number 数据
            db.number
                .clear()
                .then(() => {
                    db.number
                        .add({ numberPass: numberpass });
                });
        });

        // 发送消息
        send.addEventListener('click', () => {
            const receiver = number.value;
            const text = input.value;
            const password = passwordInput.value;

            // 空消息或空密码不发送
            if (text === '' || password === '') return;

            // 禁用输入框和发送按钮
            input.disabled = true;
            send.disabled = true;

            encryptMessage(text, password).then((encryptedMessage) => {
                const encryptedStr = Array.from(encryptedMessage).map(byte => String.fromCharCode(byte)).join('');
                socket.emit('message', {
                    receiver,
                    text: encryptedStr
                });
            }).catch((error) => {
                messages.innerHTML += `<p>加密失败：${error.message}</p>`;
                input.disabled = false;
                send.disabled = false;
            });
        });

        // 发送成功
        socket.on('ok', () => {
            messages.innerHTML += `<p>发送成功</p>`;
            input.value = '';
            input.disabled = false;
            send.disabled = false;
        });

        // 发送失败
        socket.on('fail', (error) => {
            messages.innerHTML += `<p>${error}</p>`;
            input.disabled = false;
            send.disabled = false;
        });

        function encryptMessage(message, password) {
            const encoder = new TextEncoder();
            const data = encoder.encode(message);
            const iv = crypto.getRandomValues(new Uint8Array(16));
            const keyPromise = generateKey(password);

            return keyPromise.then((key) => {
                return crypto.subtle.encrypt({ name: 'AES-CBC', iv }, key, data)
                    .then((encryptedData) => {
                        const headerBytes = encoder.encode(header);
                        const combinedData = new Uint8Array(headerBytes.length + iv.length + encryptedData.byteLength);
                        combinedData.set(headerBytes, 0);
                        combinedData.set(iv, headerBytes.length);
                        combinedData.set(new Uint8Array(encryptedData), headerBytes.length + iv.length);
                        return combinedData;
                    });
            });
        }

        function decryptMessage(encryptedMessage, password) {
            const keyPromise = generateKey(password);
            const decoder = new TextDecoder();
            const headerBytes = new TextEncoder().encode(header);

            return keyPromise.then((key) => {
                if (!encryptedMessage.slice(0, headerBytes.length).every((value, index) => value === headerBytes[index])) {
                    throw new Error('非法的消息头');
                }

                const iv = encryptedMessage.slice(headerBytes.length, headerBytes.length + 16);
                const encryptedData = encryptedMessage.slice(headerBytes.length + 16);

                return crypto.subtle.decrypt({ name: 'AES-CBC', iv }, key, encryptedData)
                    .then((decryptedData) => {
                        return decoder.decode(new Uint8Array(decryptedData));
                    })
                    .catch((e) => {
                        throw new Error('解密失败');
                    });
            });
        }

        function generateKey(password) {
            const encoder = new TextEncoder();
            const passwordBytes = encoder.encode(password);
            return crypto.subtle.digest('SHA-256', passwordBytes).then((hash) => {
                return crypto.subtle.importKey(
                    'raw',
                    hash,
                    { name: 'AES-CBC' },
                    false,
                    ['encrypt', 'decrypt']
                );
            });
        }
    </script>
</body>

</html>
